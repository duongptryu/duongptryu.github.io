<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Duongptryu | Personal blog and Profolio</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="this is meta description"><meta name=author content="Phan Tung Duong"><meta name=theme-name content="liva-hugo"><meta name=generator content="Hugo 0.109.0"><link rel=stylesheet href=https://duongptryu.github.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://duongptryu.github.io/plugins/slick/slick.css><link rel=stylesheet href=https://duongptryu.github.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://duongptryu.github.io/plugins/venobox/venobox.css><link rel=stylesheet href=https://duongptryu.github.io/scss/style.min.css media=screen><link rel="shortcut icon" href=https://duongptryu.github.io/images/favicon.png type=image/x-icon><link rel=icon href=https://duongptryu.github.io/images/favicon.png type=image/x-icon><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","Your ID","auto"),ga("send","pageview")</script></head><body><div class=preloader></div><header class=navigation><div class=container><nav class="navbar navbar-expand-lg navbar-white bg-transparent border-bottom pl-0"><a class="navbar-brand mobile-view" href=https://duongptryu.github.io/><img class=img-fluid src=https://duongptryu.github.io/images/logo.png alt="Duongptryu | Personal blog and Profolio"></a>
<button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation>
<i class=ti-menu></i></button><div class="collapse navbar-collapse text-center" id=navigation><div class=desktop-view><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=https://www.facebook.com/Ryu2532/><i class=ti-facebook></i></a></li><li class=nav-item><a class=nav-link href=#><i class=ti-twitter-alt></i></a></li><li class=nav-item><a class=nav-link href=#><i class=ti-instagram></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/duongptryu><i class=ti-github></i></a></li><li class=nav-item><a class=nav-link href=https://www.linkedin.com/in/duongptryu/><i class=ti-linkedin></i></a></li></ul></div><a class="navbar-brand mx-auto desktop-view" href=https://duongptryu.github.io/><img class=img-fluid src=https://duongptryu.github.io/images/logo.png alt="Duongptryu | Personal blog and Profolio"></a><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://duongptryu.github.io/about/>About</a></li><li class=nav-item><a class=nav-link href=https://duongptryu.github.io/profolio/>Profolio</a></li><li class=nav-item><a class=nav-link href=https://duongptryu.github.io/blog/>Blog</a></li><li class=nav-item><a class=nav-link href=https://duongptryu.github.io/contact/>Contact</a></li></ul><div class="search pl-lg-4"><button id=searchOpen class=search-btn><i class=ti-search></i></button><div class=search-wrapper><form action=https://duongptryu.github.io//search class=h-100><input class="search-box px-4" id=search-query name=s type=search placeholder="Type & Hit Enter..."></form><button id=searchClose class=search-close><i class="ti-close text-dark"></i></button></div></div></div></nav></div></header><section class=section-sm><div class=container><div class=row><div class="col-lg-8 mx-auto"><a href=/categories/golang-common-mistakes class=text-primary>Golang common mistakes</a><h2>Sai lầm khi sử dụng slicing slice trong Golang</h2><div class="mb-3 post-meta"><span>By Phan Tung Duong</span>
<span class="border-bottom border-primary px-2 mx-1"></span>
<span>08 January 2023</span></div><img src=https://duongptryu.github.io/images/featured-post/slicing-slice.png class="img-fluid w-100 mb-4" alt="Sai lầm khi sử dụng slicing slice trong Golang"><div class="content mb-5"><p>Chào mừng các bạn đã quay trở lại với series những common mistakes trong Golang. Trong bài này, chúng ta sẽ tìm hiểu về
nguyên nhân gây ra memory leak liên quan đến slice, array trong Go. Không giống như C/C++, Go có GC, vì thế chúng ta không
cần quan tâm đến memory allocation hay release. Tuy nhiên, chính vì có sự giúp đỡ của GC mà chúng ta cần hiểu cách GC hoạt động
để phòng tránh những trường hợp vô ý gây ra memory leak. Và trong bài này, chúng ta sẽ tìm hiểu về leaking memory do sử dụng
slicing slice.</p><h2 id=1-scenario>1 Scenario</h2><p>Giả sử chúng ta có một service consumer, service này sẽ nhận data dưới dạng slice, 5 vị trí đầu của slice là type của data.
Service sẽ lấy 5 phần tử đầu tiên của data để thực hiện một số chức năng.</p><p>Dưới đây sễ là ví dụ đơn giản.</p><pre tabindex=0><code>package main

import (
	&#34;fmt&#34;
	&#34;runtime&#34;
)

func main() {
	// Start
	printAlloc()
	
	dataReceived := make([]byte, 1024*1024) // Giả sử mình nhận được data slice có dung lượng là 1 MB
	printAlloc()

	typeData := getTypeOfData(dataReceived) // Lấy 5 phần tử đầu tiên của data
	// Do something with typeData
	// storeTypeDataInCache(typeData)

	runtime.GC()                // Chạy GC thu gom
	runtime.KeepAlive(typeData) // Giữ lại typeData variable
	printAlloc()
	// End
}

func getTypeOfData(data []byte) []byte {
	return data[:5] // thực hiện slicing slice
}

func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&amp;m)
	fmt.Printf(&#34;%d MB\n&#34;, m.Alloc/1024/1024)
}
</code></pre><ul><li>Ở đây để đơn giản thì mình sẽ khởi tạo <strong>dataReceived</strong> với dung lượng 1MB (Các bạn cứ hình dung là chúng ta nhận được
1MB data từ request hoặc service khác nhé :v).</li><li>Sau khi nhận được <strong>dataReceived</strong>, mình sẽ tiến hành lấy 5 phần tử đầu tiên của slice bằng cách slicing như code trên.</li><li>Cuối cùng mình sẽ dun <strong>runtime.KeepAlive</strong> để giữ <strong>typeData</strong> không bị thu gom bởi GC, để minh họa cho việc mình sẽ lưu
<strong>typeData</strong> vào memory cache của chương trình.</li><li>Sau mỗi bước mình sẽ print memory stack của process để xem hiện tại process tiêu tốn bao nhiêu dung lượng.</li></ul><p>Code không có vấn đề gì và khá dễ hiểu nhỉ. Trước khi chạy chương trình thì các bạn hay đoán xem dung lượng memory stack
khi start và end là bao nhiêu nhé. Theo lý thuyết thì dataReceived có khoảng 1 triệu phần tử thì chiếm 1MB memory, typeData
có 5 phần từ thì chiếm khoảng 5 byte he. Chạy chương trình xem có đúng vậy không nào.</p><p><img src=../../images/post/golang-slicing-slice-leak-memory/img_3.png alt=image></p><p>Âu shit, memory stack lúc nhận data và sau khi GC thu gom là giống nhau. Vậy không phải là 5 byte như chúng ta dự đoán.
Vậy có nghĩa là <strong>typeData</strong> đang giữ dung lượng là 1MB? Thế này nếu service nhận 1 nghìn data giống như này, thì memory
nó cần tận 1GB lận. Đến đây có thể các bạn sẽ nghĩ rằng một là code có vấn đề, hai là giả định của chúng ta ở trên là sai.
Vậy chúng ta cùng tìm hiểu nguyên nhân là tại sao.</p><h2 id=2-how-slice-work>2. How slice work</h2><p>Trước tiên, chúng ta cần hiểu cách slice hoạt động.</p><p>Slice trong Golang là fat pointer. Các bạn có thể đọc ở bài viết <a href=https://nullprogram.com/blog/2019/06/30/>này</a> để hiểu hơn về fat pointer.
Cấu trúc của slice bao gồm:</p><pre tabindex=0><code>type  SliceHeader  struct {
    Data  uintptr  // đỉa chỉ trong bộ nhớ của con trỏ trỏ tới underlying array của slice. 
    Len   int      // độ dài của slice.
    Cap   int      // kích thước tối đa mà vùng nhớ trỏ tới slice được cấp phát.
}
</code></pre><p>Về cơ bản, các bạn có thể hiểu là khi chúng ta có một slice thì nghĩa là chúng ta đang có một pointer trỏ tới underlying
array của slice đấy.</p><h2 id=3-reason>3. Reason</h2><p>Sau khi hiểu cách slice hoạt động, chúng ta cùng quay lại để visualize vấn đề ở trên nào.</p><p><strong>dataReceived</strong> khi init, các bạn có thể hình dung nó như này. 1 array gồm 1 triệu elements
sẽ được cấp phát ở memory stack, và dataReceived sẽ trỏ pointer tới đó.</p><p><img src=../../images/post/golang-slicing-slice-leak-memory/img_4.png alt=image></p><p>Sau đó, chúng ta tạo thêm 1 slice <strong>typeData</strong> từ slice <strong>dataReceived</strong> bằng phương pháp slicing. Khi sử dụng phương pháp
slicing thì thay vì tạo ra một underlying array mới thì Go sẽ trỏ pointer vào underlying array có sẵn đó như hình dưới đây.
Khi đó, <strong>typeData</strong> của chúng ta mặc dù chỉ có 5 phần tử nhưng capacity của nó là 1M phần tử.</p><p><img src=../../images/post/golang-slicing-slice-leak-memory/img_5.png alt=image>
Cuối cùng khi process kết thúc.</p><p><img src=../../images/post/golang-slicing-slice-leak-memory/img_6.png alt=image></p><p>Chúng ta keepAlive <strong>typeData</strong>, còn <strong>dataReceived</strong> sẽ được thu gom bởi GC. Nhưng vì
underlying array của <strong>dataReceived</strong> vẫn đang được <strong>typeData</strong> trỏ tới, nên GC sẽ không thu gom nó, mà nó vẫn sẽ
tồn tại trong memory cho đến khi nào mà không còn slice nào trỏ đến nó. Và đây chính là lý do tại sao sau khi process
kết thúc mà chúng vẫn thấy có 1MB tồn tại trong memory. Vậy giải pháp của vấn đề này là gì?</p><h2 id=4-solution>4. Solution</h2><p>Ở trên 2 slice cùng trỏ vào một underlying array, vậy nếu giờ chúng ta tách 2 slice đó thành 2 underlying array riêng biệt
thì sẽ giải quyết được vấn đề. Khi đó GC sẽ thu gom hoàn toàn <strong>dataReceived</strong> và chỉ giữ lại <strong>typeData</strong>.</p><p>Để triển khai giải pháp này, chúng ta sẽ dùng phương pháp copy slice thay vì slicing slice như trước.</p><p>Bởi vì chúng ta dùng phương pháp copy, <strong>typeData</strong> sẽ có độ dài là 5 và capacity là 5 thay vì 1M, lưu trữ 5 bytes
trong memory thay vì 1MB như trước đó.</p><p>Sửa lại function <strong>getTypeOfData</strong> nào.</p><pre tabindex=0><code>func getTypeOfData(data []byte) []byte {
	dataType := make([]byte, 5)
	copy(dataType, data)
	return dataType
}
</code></pre><p>Chạy lại và xem kết quả.</p><p><img src=../../images/post/golang-slicing-slice-leak-memory/img_7.png alt=image></p><p>Kết sau khi chúng ta update code là 0 MB. Đây là do function printAlloc() của mình đã chia dung lượng bytes cho 1024*1024 để
convert dung lượng sang MB nên nó sẽ làm tròn số float. Mình sẽ sửa lại hàm lại 1 chút để cho nó print
dung lượng bytes.</p><pre tabindex=0><code>func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&amp;m)
	fmt.Printf(&#34;%d bytes - %d MB \n&#34;, m.Alloc, m.Alloc/1024/1024)
}
</code></pre><p>Chạy lại chúng ta sẽ nhận được kết quả.</p><p><img src=../../images/post/golang-slicing-slice-leak-memory/img_8.png alt=image></p><p>Khi process khởi tạo, memory là 104800 bytes, và sau khi process kết thúc, memory là 110408 bytes, chênh lệch khoảng
5608 bytes :D. Và ở trong 5608 bytes này sẽ tồn tại 5 bytes của chúng ta lưu trữ <strong>typeData</strong>. Bởi vì khi chạy chương trình
sẽ có thêm những phần được khởi tạo và cấp phát memory ở bên dưới mà chúng ta không nhìn thấy nên con số memory sẽ có chút
chênh lệch. Nhưng thật vui khi thấy dung lượng memory không còn là 1MB như trước đúng không nào :v.</p><h2 id=5-recap>5. Recap</h2><p>Tóm lại, hãy nhớ rằng khi slicing một slice hoặc array có dung lượng lớn có thể dẫn đến leaking memory. Underlying array
sẽ không được GC thu gom khi vẫn có pointer trỏ tới. Và chúng ta có thể giữ lại underlying array rất lớn trong memory trong
khi chỉ sử dụng vài element của underlying array đó. Và copy slice là giải pháp để phòng tránh trường hợp này.</p><h2 id=6-references>6. References</h2><p>Harsanyi, T. (2022) 100 go mistakes. Shelter Island: Manning Publications.</p></div></div></div></div></section><footer class=text-capitalize><div class=container><div class="row justify-content-center"><div class="col-12 text-center mb-5"><a href=https://duongptryu.github.io/><img src=https://duongptryu.github.io/images/logo.png alt="Duongptryu | Personal blog and Profolio"></a></div><div class="col-lg-3 col-sm-6 mb-5"><h6 class=mb-4>Contact Me</h6><ul class=list-unstyled><li class=mb-3><a class=text-dark href=tel:0969360xxx><i class="ti-mobile mr-3 text-primary"></i>0969360xxx</a></li><li class=mb-3><i class="ti-location-pin mr-3 text-primary"></i>Hanoi, Vietnam</li><li class=mb-3><a class=text-dark href=mailto:duongptryu@gmail.com><i class="ti-email mr-3 text-primary"></i>duongptryu@gmail.com</a></li></ul></div><div class="col-lg-3 col-sm-6 mb-5"><h6 class=mb-4>Social Contacts</h6><ul class=list-unstyled><li class=mb-3><a class=text-dark href=https://www.facebook.com/Ryu2532/>facebook</a></li><li class=mb-3><a class=text-dark href=#>twitter</a></li><li class=mb-3><a class=text-dark href=#>instagram</a></li><li class=mb-3><a class=text-dark href=https://github.com/duongptryu>github</a></li><li class=mb-3><a class=text-dark href=https://www.linkedin.com/in/duongptryu/>linkedin</a></li></ul></div><div class="col-lg-3 col-sm-6 mb-5"><h6 class=mb-4>Categories</h6><ul class=list-unstyled><li class=mb-3><a class=text-dark href=/categories/golang-common-mistakes/>Golang common mistakes</a></li></ul></div><div class="col-lg-3 col-sm-6 mb-5"><h6 class=mb-4>Quick Links</h6><ul class=list-unstyled><li class=mb-3><a class=text-dark href=https://duongptryu.github.io/about/>About</a></li><li class=mb-3><a class=text-dark href=https://duongptryu.github.io/blog/>Post</a></li><li class=mb-3><a class=text-dark href=https://duongptryu.github.io/contact/>Contact</a></li></ul></div><div class="col-12 border-top py-4 text-center">| copyright © 2021 <a href=https://themefisher.com/hugo-themes/>Themefisher</a> All Rights Reserved |</div></div></div></footer><script>var indexURL="https://duongptryu.github.io/index.json"</script><script src=https://duongptryu.github.io/plugins/jQuery/jquery.min.js></script>
<script src=https://duongptryu.github.io/plugins/bootstrap/bootstrap.min.js></script>
<script src=https://duongptryu.github.io/plugins/slick/slick.min.js></script>
<script src=https://duongptryu.github.io/plugins/venobox/venobox.min.js></script>
<script src=https://duongptryu.github.io/plugins/search/fuse.min.js></script>
<script src=https://duongptryu.github.io/plugins/search/mark.js></script>
<script src=https://duongptryu.github.io/plugins/search/search.js></script>
<script src=https://duongptryu.github.io/js/script.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js></script><div id=js-cookie-box class="cookie-box cookie-box-hide">This site uses cookies. By continuing to use this website, you agree to their use. <span id=js-cookie-button class="btn btn-sm btn-primary ml-2">I Accept</span></div><script>(function(){const t=document.getElementById("js-cookie-box"),n=document.getElementById("js-cookie-button");Cookies.get("cookie-box")||(t.classList.remove("cookie-box-hide"),n.onclick=function(){Cookies.set("cookie-box",!0,{expires:2}),t.classList.add("cookie-box-hide")})})(jQuery)</script><style>.cookie-box{position:fixed;left:0;right:0;bottom:0;text-align:center;z-index:9999;padding:1rem 2rem;background:#474747;transition:all .75s cubic-bezier(.19,1,.22,1);color:#fdfdfd}.cookie-box-hide{display:none}</style></body></html>