<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Duongptryu | Personal blog and Profolio</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="this is meta description"><meta name=author content="Phan Tung Duong"><meta name=theme-name content="liva-hugo"><meta name=generator content="Hugo 0.109.0"><link rel=stylesheet href=https://duongptryu.github.io/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://duongptryu.github.io/plugins/slick/slick.css><link rel=stylesheet href=https://duongptryu.github.io/plugins/themify-icons/themify-icons.css><link rel=stylesheet href=https://duongptryu.github.io/plugins/venobox/venobox.css><link rel=stylesheet href=https://duongptryu.github.io/scss/style.min.css media=screen><link rel="shortcut icon" href=https://duongptryu.github.io/images/favicon.png type=image/x-icon><link rel=icon href=https://duongptryu.github.io/images/favicon.png type=image/x-icon><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","Your ID","auto"),ga("send","pageview")</script></head><body><div class=preloader></div><header class=navigation><div class=container><nav class="navbar navbar-expand-lg navbar-white bg-transparent border-bottom pl-0"><a class="navbar-brand mobile-view" href=https://duongptryu.github.io/><img class=img-fluid src=https://duongptryu.github.io/images/logo.png alt="Duongptryu | Personal blog and Profolio"></a>
<button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation>
<i class=ti-menu></i></button><div class="collapse navbar-collapse text-center" id=navigation><div class=desktop-view><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link href=https://www.facebook.com/Ryu2532/><i class=ti-facebook></i></a></li><li class=nav-item><a class=nav-link href=https://github.com/duongptryu><i class=ti-github></i></a></li><li class=nav-item><a class=nav-link href=https://www.linkedin.com/in/duongptryu/><i class=ti-linkedin></i></a></li></ul></div><a class="navbar-brand mx-auto desktop-view" href=https://duongptryu.github.io/><img class=img-fluid src=https://duongptryu.github.io/images/logo.png alt="Duongptryu | Personal blog and Profolio"></a><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://duongptryu.github.io/about/>About</a></li><li class=nav-item><a class=nav-link href=https://duongptryu.github.io/profolio/>Profolio</a></li><li class=nav-item><a class=nav-link href=https://duongptryu.github.io/blog/>Blog</a></li><li class=nav-item><a class=nav-link href=https://duongptryu.github.io/contact/>Contact</a></li></ul><div class="search pl-lg-4"><button id=searchOpen class=search-btn><i class=ti-search></i></button><div class=search-wrapper><form action=https://duongptryu.github.io//search class=h-100><input class="search-box px-4" id=search-query name=s type=search placeholder="Type & Hit Enter..."></form><button id=searchClose class=search-close><i class="ti-close text-dark"></i></button></div></div></div></nav></div></header><section class=section-sm><div class=container><div class=row><div class="col-lg-8 mx-auto"><a href=/categories/golang-common-mistakes class=text-primary>Golang common mistakes</a><h2>Memory leak do sử dụng map sai cách trong Golang?</h2><div class="mb-3 post-meta"><span>By Phan Tung Duong</span>
<span class="border-bottom border-primary px-2 mx-1"></span>
<span>08 January 2023</span></div><img src=https://duongptryu.github.io/images/featured-post/map_and_leak_memory.png class="img-fluid w-100 mb-4" alt="Memory leak do sử dụng map sai cách trong Golang?"><div class="content mb-5"><p>Như các bạn đã biết thì map là một data type được dựng sẵn trong Golang và nó là một tập hợp các cặp key/value.
Nghe thì thấy khá đơn giản nhỉ, khi cần thì add record vào map, còn không cần nữa thì xóa đi.
Ủa, đơn giản như vậy mà lại còn được buildin nữa thì sao lại dẫn đến leak memory được, đây là mind set của mình khi mới dùng Go đấy
Không dài dòng nữa, mình sẽ đưa ví dụ luôn.</p><h2 id=1-tình-huống>1. Tình huống</h2><pre tabindex=0><code>package main 

import (
	&#34;runtime&#34;
	&#34;fmt&#34;
)

func main() {
    // Init
    n := 1_000_000
    m := make(map[int][128]byte)
    printAlloc()
    
    // Add elements
    for i := 0; i &lt; n; i++ {
    m[i] = randBytes()
    }
    printAlloc()
    
    // Remove elements
    for i := 0; i &lt; n; i++ {
    delete(m, i)
    }
    
    // End
    runtime.GC()
    printAlloc()
    runtime.KeepAlive(m)
}

func randBytes() [128]byte {
    return [128]byte{}
}

func printAlloc() {
    var m runtime.MemStats
    runtime.ReadMemStats(&amp;m)
    fmt.Printf(&#34;%d MB\n&#34;, m.Alloc/1024/1024)
}
</code></pre><ol><li>Đầu tiên chúng ta sẽ cấp phát memory, khởi tạo empty map m</li><li>Tiếp theo đó loop 1 triệu lần để gắn elelemt cho m</li><li>Cuối cùng là remove tất cả elements trong m và chạy GC</li></ol><p>Sau mỗi bước trên, chúng ta sẽ log size của heap memory bằng runtime.MemStats (MemStats records statistics about the
memory allocator).
Dòng cuối cùng <strong>runtime.KeepAlive(m)</strong> để giữ lại reference tới map m không bị thu gom bởi GC.
Oke, chạy chương trình nào, cùng dự đoán nhé!!</p><p><img src=../../images/post/golang-map-leak-memory/img_1.png alt=image></p><p>Woww, kết quả này có giống như dự đoán của các bạn không?</p><p>Sau khi cấp phát memory cho map m, heap size là nhỏ nhất - 0 MB.
Sau đó heap size tăng nhanh chóng khi add 1 triệu element vào map m. Cuối cùng, mặc dù GC đã thu gom hết các element bị
xóa khỏi map,
nhưng heap size vẫn là 293 MB. Heap memory size đã giảm nhưng không như chúng ta mong muốn là 0 MB, right? Vậy đâu
là nguyên do?.</p><h2 id=2-nguyên-nhân-là-do-đâu>2. Nguyên nhân là do đâu?</h2><p>Trước khi tìm ra nguyên do, chúng ta cần phải biết cách map hoạt động trong golang.</p><p>Về cơ bản, Map trong Go là 1 con trỏ đến runtime.hmap, struct hmap này chứa rất nhiều field, trong đó có B field là
thể hiện số lượng bucket hiện có trong map.
Mỗi bucket này lại là pointer tới array (mỗi array chỉ có 8 phần tử, khi hết thì tạo thêm array mới và link với
array trước) chứa các element của map. Nên khi chúng ta thêm element vào map, thì nghĩa là chúng ta đang thêm element vào
bucket. Tương tự như lúc xóa cũng vậy.
Mình sẽ để link ở đây cho bạn nào muốn tìm hiểu kỹ hơn về phần này: <a href=https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics>https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a></p><p><img src=../../images/post/golang-map-leak-memory/img_2.png alt=image></p><p>Nhưng có một điều lưu ý ở đây là khi thêm elemenet vào map, số lượng bucket sẽ được cấp phát và tăng lên, element
được thêm vào bucket, nhưng khi tiến hành xóa element
trong map, thì chúng ta chỉ xóa element trong bucket đấy thôi chứ sẽ không xóa số lượng bucket được cấp phát trước đó.</p><p>Như trong cuốn sách <a href=https://www.amazon.com/100-Mistakes-How-Avoid-Them/dp/1617299596>100 Mistakes In Golang</a> ở
page 88, tác giả đưa ra con số bucket là 262,144 buckets khi thêm 1 triệu element vào, và khi xóa đi thì số lượng
bucket vẫn là 262,144.</p><p>=> Kết luận: Số lượng bucket trong map chỉ tăng lên chứ không giảm đi. Và đây chính là nguyên nhân dẫn đến số lượng
heap size giảm không đúng theo expected của chúng ta. Vì GC chỉ thu gom
những element đã được xóa trong bucket chứ không tác động lên map.</p><h2 id=3-đây-có-thực-sự-là-vấn-đề>3. Đây có thực sự là vấn đề?</h2><p>Theo quan điểm của mình thì việc các buckets này không bị xóa đi khi element bị xóa cũng chưa hẳn là xấu.
Tốt hay xấu thì cũng phải tùy từng tình huống.</p><p>Nếu map của các chúng ta chứa element mà không cần CUD thì tất nhiên sẽ không gặp vấn đề này.
Còn nếu map chứa element thường xuyên phải insert và delete thì tất nhiên sẽ gặp vấn đề này. Nhưng trong tình huống
này cũng có cái tốt và cái xấu. Khi chúng ta xóa element đi rồi lại thêm element mới vào thường xuyên, thì các bucket
trong map vẫn giữ nguyên, hệ thống sẽ không cần phải cấp phát lại bucket nữa, qua đó sẽ tăng performance xíu xíu cho
hệ thống :v. Còn mặt xấu thì các bạn thấy rồi đấy, memory sẽ không giảm đúng theo expected của chúng ta,
dev mà không có kinh nghiệm về mảng này là mò hoài không ra lý do tại sao Mem cứ tăng mà giảm xíu xíu, xong rồi lại
bị sếp đè đầu hỏi =)))</p><p>Trong thực tế thì case này rất dễ xảy ra, ví dụ khi hệ thống của bạn sử dụng map để lưu data cache của user, vào các ngày khuyến mại
lớn như 1/1, có hàng triệu triệu người dùng vào website mua sắm. Nhưng sau đó vài ngày, bạn vẫn thấy lượng Mem của server ở
mức cao mà không hề giảm, thế là ông sếp lại đè đầu bạn ra để trừ lương :v.</p><p>Cách đây vài tháng, mình cũng từng gặp case như vậy, mình làm freelance cho một công ty về mảng live stream, nội dung
giải trí, truyền hình trực tuyến.
Họ dùng cache local để lưu lại data của người dùng và toàn bộ thông tin về danh mục xem của mỗi người dùng (cái data
này to vcl lun). Xong mỗi lần chạy
load testing cái là memory của server nó tăng như tên lửa, không giảm tý nào luôn. Sếp mình lúc đấy chắc cũng bế tắc,
thế là đá cái task đấy cho mình, bảo mình nghiên cứu xem sao mem k giảm =)). Mình lúc đấy
là thằng sv mới ra truường thì có biết gì đâu. Ngồi nghiên cứu cả tháng trời mà
không có báo cáo gì. Kết quả là gì thì các bạn cũng đoán được rồi đấy =)))</p><h2 id=4-giải-pháp>4. Giải pháp</h2><p>Giải pháp đơn giản nhất là reset service rồi, nhưng chúng ta đâu thể tự reset đúng không, lại phải ới ông devops bảo
&ldquo;Alo a ơi, a reset con service X hộ e với&rdquo;. Gặp ông devops dễ thì không sao, chứ gặp ông khó tính thì dời ơi đất hỡi lắm.
Mà reset một lần thì có thể không sao, chứ reset nhiều lần trong 1 tháng thì mình nghĩ chắc cũng sắp nghỉ việc rồi đấy =))</p><p>Giải pháp tiếp theo là tạo lại map đó. Giả sử chúng ta chạy 1 goroutine, cứ mỗi 1 tiếng thì nó lại copy tất cả element trong
map cũ và thêm vào map mới, xong replace map cũ là xong. Nhưng cái này cũng có nhược điểm, sau khi copy tất cả elements sang map mới
thì mem của chúng ta vẫn tồn tại map cũ cho đến khi GC lần tiếp theo thu gom.</p><p>Một giải pháp khác là chúng ta lưu trữ con trỏ trỏ đến data, chứ không lưu trực tiếp data trong map. Nó không xử lý được vấn đề
về số lượng bucket không giảm, nhưng nó sẽ giảm kích thước phải lưu trữ trong bucket.</p><h2 id=5-summary>5. Summary</h2><p>Chúng ta cần phải chú ý khi dụng map trong golang nếu không muốn những tháng ngày debug không lối thoát :v.
Các bạn nên cân nhắc xem tình huống này có sử dụng map được không, và nếu sử dụng thì sẽ gặp vấn đề gì khi số lượng
element trong map phình to. Và cuối cùng là phải ghi nhớ: <strong>&ldquo;Go map can only grow in size, there is not automated strategy to shrink it.&rdquo;</strong></p><p>P/s:
Đây là lần đầu tiên mình viết bài chia sẻ kiến thức, và kinh nghiệm của mình vẫn còn khá ít, chủ yếu là trên sách vở,
sẽ không thể tránh được những sai lầm. Nhưng mình luôn luôn có mong muốn được chia sẻ những kiến thức mà mình biết đến
với mọi người, đặc biệt là gopher :v. Nên mình rất mong muốn có những phản hồi đóng góp chia sẻ của các độc giả để các bài sau
mình có thêm động lực để viết tốt hơn. Thanks for everyone !!!!</p><h2 id=6-references>6. References</h2><p><a href=https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics>https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a></p><p>Harsanyi, T. (2022) 100 go mistakes. Shelter Island: Manning Publications.</p></div></div></div></div></section><footer class=text-capitalize><div class=container><div class="row justify-content-center"><div class="col-12 text-center mb-5"><a href=https://duongptryu.github.io/><img src=https://duongptryu.github.io/images/logo.png alt="Duongptryu | Personal blog and Profolio"></a></div><div class="col-lg-3 col-sm-6 mb-5"><h6 class=mb-4>Contact Me</h6><ul class=list-unstyled><li class=mb-3><a class=text-dark href=tel:0969360xxx><i class="ti-mobile mr-3 text-primary"></i>0969360xxx</a></li><li class=mb-3><i class="ti-location-pin mr-3 text-primary"></i>Hanoi, Vietnam</li><li class=mb-3><a class=text-dark href=mailto:duongptryu@gmail.com><i class="ti-email mr-3 text-primary"></i>duongptryu@gmail.com</a></li></ul></div><div class="col-lg-3 col-sm-6 mb-5"><h6 class=mb-4>Social Contacts</h6><ul class=list-unstyled><li class=mb-3><a class=text-dark href=https://www.facebook.com/Ryu2532/>facebook</a></li><li class=mb-3><a class=text-dark href=https://github.com/duongptryu>github</a></li><li class=mb-3><a class=text-dark href=https://www.linkedin.com/in/duongptryu/>linkedin</a></li></ul></div><div class="col-lg-3 col-sm-6 mb-5"><h6 class=mb-4>Categories</h6><ul class=list-unstyled><li class=mb-3><a class=text-dark href=/categories/golang-common-mistakes/>Golang common mistakes</a></li></ul></div><div class="col-lg-3 col-sm-6 mb-5"><h6 class=mb-4>Quick Links</h6><ul class=list-unstyled><li class=mb-3><a class=text-dark href=https://duongptryu.github.io/about/>About</a></li><li class=mb-3><a class=text-dark href=https://duongptryu.github.io/blog/>Post</a></li><li class=mb-3><a class=text-dark href=https://duongptryu.github.io/contact/>Contact</a></li></ul></div><div class="col-12 border-top py-4 text-center">| copyright © 2021 <a href=https://themefisher.com/hugo-themes/>Themefisher</a> All Rights Reserved |</div></div></div></footer><script>var indexURL="https://duongptryu.github.io/index.json"</script><script src=https://duongptryu.github.io/plugins/jQuery/jquery.min.js></script>
<script src=https://duongptryu.github.io/plugins/bootstrap/bootstrap.min.js></script>
<script src=https://duongptryu.github.io/plugins/slick/slick.min.js></script>
<script src=https://duongptryu.github.io/plugins/venobox/venobox.min.js></script>
<script src=https://duongptryu.github.io/plugins/search/fuse.min.js></script>
<script src=https://duongptryu.github.io/plugins/search/mark.js></script>
<script src=https://duongptryu.github.io/plugins/search/search.js></script>
<script src=https://duongptryu.github.io/js/script.min.js></script></body></html>